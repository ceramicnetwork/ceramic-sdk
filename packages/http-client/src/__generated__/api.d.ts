/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/liveness': {
    /** Test the liveness of the Ceramic node */
    get: {
      responses: {
        /** @description success */
        200: {
          content: never
        }
        /** @description Internal server error */
        500: {
          content: {
            'application/json': components['schemas']['ErrorResponse']
          }
        }
      }
    }
  }
  '/debug/heap': {
    /** Get the heap statistics of the Ceramic node */
    get: {
      responses: {
        /** @description success */
        200: {
          content: {
            'application/octet-stream': string
          }
        }
        /** @description bad request */
        400: {
          content: {
            'application/json': components['schemas']['BadRequestResponse']
          }
        }
        /** @description Internal server error */
        500: {
          content: {
            'application/json': components['schemas']['ErrorResponse']
          }
        }
      }
    }
  }
  '/version': {
    /** Get the version of the Ceramic node */
    post: {
      responses: {
        /** @description success */
        200: {
          content: {
            'application/json': components['schemas']['Version']
          }
        }
        /** @description Internal server error */
        500: {
          content: {
            'application/json': components['schemas']['ErrorResponse']
          }
        }
      }
    }
  }
  '/events': {
    /** Creates a new event */
    post: {
      requestBody: components['requestBodies']['Event']
      responses: {
        /** @description success */
        204: {
          content: never
        }
        /** @description bad request */
        400: {
          content: {
            'application/json': components['schemas']['BadRequestResponse']
          }
        }
        /** @description Internal server error */
        500: {
          content: {
            'application/json': components['schemas']['ErrorResponse']
          }
        }
      }
    }
  }
  '/events/{event_id}': {
    /** Get event data */
    get: {
      parameters: {
        path: {
          /** @description identifier of the event */
          event_id: string
        }
      }
      responses: {
        /** @description success */
        200: {
          content: {
            'application/json': components['schemas']['Event']
          }
        }
        /** @description bad request */
        400: {
          content: {
            'application/json': components['schemas']['BadRequestResponse']
          }
        }
        /** @description Event not found */
        404: {
          content: {
            'text/plain': string
          }
        }
        /** @description Internal server error */
        500: {
          content: {
            'application/json': components['schemas']['ErrorResponse']
          }
        }
      }
    }
  }
  '/interests/{sort_key}/{sort_value}': {
    /** Register interest for a sort key */
    post: {
      parameters: {
        query?: {
          /** @description the controller to register interest for */
          controller?: string
          /** @description the stream to register interest for */
          streamId?: string
        }
        path: {
          /** @description name of the sort_key */
          sort_key: string
          /** @description value associated with the sort key */
          sort_value: string
        }
      }
      responses: {
        /** @description success */
        204: {
          content: never
        }
        /** @description bad request */
        400: {
          content: {
            'application/json': components['schemas']['BadRequestResponse']
          }
        }
        /** @description Internal server error */
        500: {
          content: {
            'application/json': components['schemas']['ErrorResponse']
          }
        }
      }
    }
  }
  '/interests': {
    /** Register interest for a sort key */
    post: {
      requestBody: components['requestBodies']['Interest']
      responses: {
        /** @description success */
        204: {
          content: never
        }
        /** @description bad request */
        400: {
          content: {
            'application/json': components['schemas']['BadRequestResponse']
          }
        }
        /** @description Internal server error */
        500: {
          content: {
            'application/json': components['schemas']['ErrorResponse']
          }
        }
      }
    }
  }
  '/experimental/events/{sep}/{sepValue}': {
    /** Get events matching the interest stored on the node */
    get: {
      parameters: {
        query?: {
          /** @description the controller to filter (DID string) */
          controller?: string
          /** @description the stream to filter (multibase encoded stream ID) */
          streamId?: string
          /** @description token that designates the point to resume from, that is find keys added after this point */
          offset?: number
          /** @description the maximum number of events to return, default is 10000. */
          limit?: number
        }
        path: {
          /** @description Name of the field in the Events header that holds the separator value e.g. 'model' */
          sep: string
          /** @description The value of the field in the Events header indicated by the separator key me.g. multibase encoded model ID */
          sepValue: string
        }
      }
      responses: {
        /** @description success */
        200: {
          content: {
            'application/json': components['schemas']['EventsGet']
          }
        }
        /** @description bad request */
        400: {
          content: {
            'application/json': components['schemas']['BadRequestResponse']
          }
        }
        /** @description Internal server error */
        500: {
          content: {
            'application/json': components['schemas']['ErrorResponse']
          }
        }
      }
    }
  }
  '/feed/events': {
    /** Get all new event keys since resume token */
    get: {
      parameters: {
        query?: {
          /** @description token that designates the point to resume from, that is find keys added after this point */
          resumeAt?: string
          /** @description the maximum number of events to return, default is 10000. */
          limit?: number
        }
      }
      responses: {
        /** @description success */
        200: {
          content: {
            'application/json': components['schemas']['EventFeed']
          }
        }
        /** @description bad request */
        400: {
          content: {
            'application/json': components['schemas']['BadRequestResponse']
          }
        }
        /** @description Internal server error */
        500: {
          content: {
            'application/json': components['schemas']['ErrorResponse']
          }
        }
      }
    }
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    /**
     * @description Version of the Ceramic node in semver format, e.g. 2.1.0
     * @example {
     *   "version": "version"
     * }
     */
    Version: {
      /** @description Version of the Ceramic node */
      version?: string
    }
    /**
     * Response to a bad request (400)
     * @description Bad request (input error)
     */
    BadRequestResponse: {
      /** @description Message describing the error */
      message: string
    }
    /**
     * A Ceramic Event
     * @description A Ceramic event as part of a Ceramic Stream
     * @example {
     *   "data": "data",
     *   "id": "id"
     * }
     */
    Event: {
      /** @description Multibase encoding of event id bytes. */
      id: string
      /** @description Multibase encoding of event data. */
      data: string
    }
    /**
     * Ceramic Event feed data
     * @description Ceramic event keys as part of a Ceramic Stream
     * @example {
     *   "resumeToken": "resumeToken",
     *   "events": [
     *     {
     *       "data": "data",
     *       "id": "id"
     *     },
     *     {
     *       "data": "data",
     *       "id": "id"
     *     }
     *   ]
     * }
     */
    EventFeed: {
      /** @description An array of events. For now, the value is empty. */
      events: components['schemas']['Event'][]
      /** @description The token/highwater mark to used as resumeAt on a future request */
      resumeToken: string
    }
    /**
     * Information about multiple events.
     * @description Ceramic event keys as part of a Ceramic Stream
     * @example {
     *   "resumeOffset": 0,
     *   "events": [
     *     {
     *       "data": "data",
     *       "id": "id"
     *     },
     *     {
     *       "data": "data",
     *       "id": "id"
     *     }
     *   ],
     *   "isComplete": true
     * }
     */
    EventsGet: {
      /** @description An array of events */
      events: components['schemas']['Event'][]
      /** @description An integer specifying where to resume the request. Only works correctly for the same input parameters. */
      resumeOffset: number
      /** @description A boolean specifying if there are more events to be fetched. Repeat with the resumeOffset to get next set. */
      isComplete: boolean
    }
    /**
     * Error response
     * @description Error response
     */
    ErrorResponse: {
      /** @description Error message */
      message: string
    }
    /**
     * A recon interest
     * @description Describes a recon interest range to store and synchronize
     * @example {
     *   "controller": "controller",
     *   "streamId": "streamId",
     *   "sepValue": "sepValue",
     *   "sep": "sep"
     * }
     */
    Interest: {
      /** @description Separator key, typically 'model' (sometimes called sort_key) */
      sep: string
      /** @description Multibase encoded separator value (sometimes called sort_value, typically a stream ID) */
      sepValue: string
      /** @description Decentralized identifier (DID) string */
      controller?: string
      /** @description Multibase encoded stream ID. */
      streamId?: string
    }
  }
  responses: never
  parameters: never
  requestBodies: {
    /** @description Event to add to the node */
    Event: {
      content: {
        'application/json': components['schemas']['Event']
      }
    }
    /** @description Recon message to send */
    Message: {
      content: {
        'application/cbor-seq': string
      }
    }
    /** @description Interest to register on the node */
    Interest: {
      content: {
        'application/json': components['schemas']['Interest']
      }
    }
  }
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export type operations = Record<string, never>
